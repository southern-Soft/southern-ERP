# Design Document

## Overview

This design addresses critical fixes and enhancements to the ERP system, focusing on resolving client information loading errors, adding buyer type management, enhancing sample and manufacturing operations, and completing merchandising module features. The solution follows the existing React/TypeScript frontend architecture with TanStack Query for data management and a Python FastAPI backend.

## Architecture

The ERP system follows a modern web application architecture:

**Frontend Stack:**
- Next.js 14 with App Router
- TypeScript for type safety
- TanStack Query for server state management
- Tailwind CSS with shadcn/ui components
- React Hook Form for form management

**Backend Stack:**
- Python FastAPI with SQLAlchemy ORM
- PostgreSQL database
- RESTful API design
- Modular service architecture

**Key Architectural Patterns:**
- Service layer pattern for API calls
- Custom hooks for data fetching and mutations
- Component composition with UI library
- Error boundary and loading state management

## Components and Interfaces

### 1. Client Information Error Resolution

**Problem Analysis:**
The shipping and banking pages show "Failed to load" errors due to query hook failures or API endpoint issues.

**Solution Components:**

**Enhanced Error Handling Service:**
```typescript
interface ErrorHandlingService {
  retryWithBackoff(operation: () => Promise<any>, maxRetries: number): Promise<any>
  logError(error: Error, context: string): void
  getErrorMessage(error: unknown): string
}
```

**Improved Query Hooks:**
```typescript
interface ImprovedQueryHook {
  data: T | undefined
  isLoading: boolean
  isError: boolean
  error: Error | null
  refetch: () => void
  retry: () => void
}
```

### 2. Buyer Type Management

**New Components:**

**BuyerTypeSelector Component:**
```typescript
interface BuyerTypeSelectorProps {
  value?: string
  onChange: (value: string) => void
  allowCreate?: boolean
  placeholder?: string
}
```

**BuyerType Service:**
```typescript
interface BuyerTypeService {
  getAll(): Promise<BuyerType[]>
  create(data: CreateBuyerTypeData): Promise<BuyerType>
  update(id: number, data: UpdateBuyerTypeData): Promise<BuyerType>
  delete(id: number): Promise<void>
}
```

### 3. Sample Operations Enhancement

**Enhanced Sample Operations Interface:**
```typescript
interface SampleOperation {
  id: number
  sampleRequestId: number
  operationName: string
  operationType: string
  sequence: number
  estimatedTime?: number
  actualTime?: number
  status: 'pending' | 'in_progress' | 'completed'
  notes?: string
  createdAt: Date
  updatedAt: Date
}

interface SampleOperationsManager {
  addOperation(sampleId: number, operation: CreateSampleOperationData): Promise<SampleOperation>
  updateOperation(id: number, data: UpdateSampleOperationData): Promise<SampleOperation>
  deleteOperation(id: number): Promise<void>
  reorderOperations(sampleId: number, operationIds: number[]): Promise<void>
}
```

### 4. Manufacturing Operations Management

**Manufacturing Operations Interface:**
```typescript
interface ManufacturingOperation {
  id: number
  operationName: string
  description?: string
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}

interface ManufacturingOperationsService {
  getAll(isActive?: boolean): Promise<ManufacturingOperation[]>
  create(data: CreateManufacturingOperationData): Promise<ManufacturingOperation>
  update(id: number, data: UpdateManufacturingOperationData): Promise<ManufacturingOperation>
  delete(id: number): Promise<void>
}
```

### 5. Merchandising Module Enhancements

**Enhanced Material Management:**
```typescript
interface MaterialDetail {
  id: string
  materialName: string
  category: string
  colorOut?: string
  uomOut?: string
  conversionRate?: number
  yarnComposition?: YarnComposition[]
  trims?: Trim[]
  finishedGoodCategory?: string
  packingSpecs?: PackingSpecification
}

interface UOMConversionService {
  calculateConversion(fromUOM: string, toUOM: string, quantity: number): Promise<number>
  getConversionRates(materialId: string): Promise<ConversionRate[]>
}
```

**Size Chart Management:**
```typescript
interface SizeChart {
  id: string
  name: string
  category: string
  measurements: SizeMeasurement[]
  unit: 'mm' | 'cm' | 'inch'
  isAutoGenerated: boolean
}

interface SizeChartService {
  generateAutomatic(category: string, baseSize: string): Promise<SizeChart>
  addCustomSize(chartId: string, measurement: SizeMeasurement): Promise<void>
}
```

### 6. Sample Request Enhancements

**Enhanced Sample Request Interface:**
```typescript
interface SampleRequest {
  id: number
  sampleId: string
  buyerId: number
  category: string
  status: string
  gauge?: string // Formatted as "12 GG"
  colors: Color[]
  sizes: Size[]
  sizeDetails: SizeDetail[]
  createdAt: Date
  updatedAt: Date
}

interface SampleRequestSearchService {
  search(query: string, filters: SearchFilters): Promise<SampleRequest[]>
  getGaugeOptions(): Promise<GaugeOption[]>
  getAvailableColors(): Promise<Color[]>
  getAvailableSizes(): Promise<Size[]>
}
```

## Data Models

### BuyerType Model
```typescript
interface BuyerType {
  id: number
  name: string
  description?: string
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}
```

### Enhanced Buyer Model
```typescript
interface Buyer {
  id: number
  buyerName: string
  companyName: string
  brandName?: string
  buyerTypeId?: number // New field
  buyerType?: BuyerType // Populated relation
  // ... existing fields
}
```

### SampleOperation Model
```typescript
interface SampleOperation {
  id: number
  sampleRequestId: number
  manufacturingOperationId: number
  sequence: number
  estimatedTime?: number
  actualTime?: number
  status: OperationStatus
  notes?: string
  assignedTo?: string
  startedAt?: Date
  completedAt?: Date
  createdAt: Date
  updatedAt: Date
}
```

### Enhanced Material Models
```typescript
interface YarnComposition {
  id: number
  materialId: string
  yarnType: string
  percentage: number
  category: string
}

interface Trim {
  id: number
  materialId: string
  trimType: string
  category?: string
  specifications?: string
}

interface PackingSpecification {
  id: number
  materialId: string
  cartonLength: number
  cartonWidth: number
  cartonHeight: number
  cartonWeight: number
  unit: string
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property Reflection

After analyzing all acceptance criteria, I identified several areas where properties can be consolidated:
- Properties 1.1 and 1.2 both test data loading without errors and can be combined into a general data loading property
- Properties 3.1-3.5 all test sample operation management and can be consolidated into fewer comprehensive properties
- Properties 5.3, 5.4, and 5.5 all test category option availability and can be combined
- Properties 6.3 and 6.4 both test multi-selection capabilities and can be unified

### Core Properties

**Property 1: Client Data Loading Reliability**
*For any* client data module (shipping or banking), when data is requested, the system should either return valid data or display appropriate empty/retry states without showing generic error messages
**Validates: Requirements 1.1, 1.2, 1.3**

**Property 2: Network Error Recovery**
*For any* network request failure, the system should provide retry functionality with exponential backoff and clear error descriptions
**Validates: Requirements 1.4**

**Property 3: Buyer Type Management Persistence**
*For any* buyer type selection or creation, the system should persist the data correctly and make it available for future use
**Validates: Requirements 2.2, 2.4, 2.5**

**Property 4: Sample Operation Independence**
*For any* sample with multiple operations, modifying or deleting one operation should not affect the state or data of other operations
**Validates: Requirements 3.2, 3.4, 3.5**

**Property 5: Sample Operation Collection Management**
*For any* sample, the system should allow adding multiple operations and display all associated operations correctly
**Validates: Requirements 3.1, 3.3**

**Property 6: Manufacturing Operation Validation**
*For any* manufacturing operation creation, the system should accept operations with only a name field and validate uniqueness and non-emptiness
**Validates: Requirements 4.1, 4.2, 4.4**

**Property 7: Manufacturing Operation Interface Separation**
*For any* manufacturing operation management, the system should provide search and sort capabilities independent of sample operations
**Validates: Requirements 4.5**

**Property 8: UOM Conversion Accuracy**
*For any* valid UOM conversion request, the system should calculate and display mathematically correct conversion rates
**Validates: Requirements 5.2**

**Property 9: Category Options Availability**
*For any* material component (yarn, trims, finished goods), the system should provide appropriate category options and handle null selections correctly
**Validates: Requirements 5.3, 5.4, 5.5**

**Property 10: Material Specification Capture**
*For any* material or packing good, the system should accurately capture and store all required specifications including dimensions and weights
**Validates: Requirements 5.1, 5.6**

**Property 11: Size Chart Generation**
*For any* size chart creation, the system should provide automatic generation with mm as default units and allow manual entry when automatic data is unavailable
**Validates: Requirements 5.7, 5.8**

**Property 12: Sample Request Search Functionality**
*For any* search query on sample requests, the system should return results that match the query across all searchable fields
**Validates: Requirements 6.1**

**Property 13: Multi-Selection Capability**
*For any* sample request, the system should allow selection of multiple colors and multiple sizes independently
**Validates: Requirements 6.3, 6.4**

**Property 14: Gauge Formatting Consistency**
*For any* gauge option display, the system should format options consistently with proper spacing (e.g., "12 GG")
**Validates: Requirements 6.2**

**Property 15: Size Detail Data Fetching**
*For any* size detail request, the system should fetch and display comprehensive size information accurately
**Validates: Requirements 6.5**

**Property 16: Form Validation Completeness**
*For any* sample request submission, the system should validate all required fields and prevent submission with missing or invalid data
**Validates: Requirements 6.6**

**Property 17: Error Logging Comprehensiveness**
*For any* system error, the system should log detailed information sufficient for debugging and troubleshooting
**Validates: Requirements 7.1**

**Property 18: User Feedback Quality**
*For any* validation failure, the system should provide clear, actionable error messages that help users correct the issue
**Validates: Requirements 7.3**

**Property 19: Bulk Operation Feedback**
*For any* bulk operation, the system should provide progress indicators and allow cancellation at any point during execution
**Validates: Requirements 7.5**

## Error Handling

### Error Categories and Strategies

**1. Network Errors**
- Implement exponential backoff retry logic
- Provide clear retry buttons with status indicators
- Cache last successful data when possible
- Display network-specific error messages

**2. Validation Errors**
- Client-side validation for immediate feedback
- Server-side validation for data integrity
- Field-level error messages with correction hints
- Form-level validation summaries

**3. Data Loading Errors**
- Distinguish between empty data and error states
- Provide appropriate empty state messages
- Implement graceful degradation for partial failures
- Log detailed error context for debugging

**4. User Input Errors**
- Real-time validation feedback
- Clear error message formatting
- Contextual help and examples
- Prevention of invalid state submission

### Error Recovery Mechanisms

**Retry Logic Implementation:**
```typescript
interface RetryConfig {
  maxRetries: number
  baseDelay: number
  maxDelay: number
  backoffMultiplier: number
}

const defaultRetryConfig: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
  backoffMultiplier: 2
}
```

**Error Boundary Strategy:**
- Component-level error boundaries for isolated failures
- Global error boundary for unhandled exceptions
- Error reporting and logging integration
- Graceful fallback UI components

## Testing Strategy

### Dual Testing Approach

The testing strategy employs both unit testing and property-based testing to ensure comprehensive coverage:

**Unit Tests:**
- Specific examples and edge cases
- Integration points between components
- Error conditions and boundary cases
- UI component behavior verification

**Property-Based Tests:**
- Universal properties across all inputs
- Comprehensive input coverage through randomization
- Validation of system invariants
- Cross-component interaction testing

### Property-Based Testing Configuration

**Testing Framework:** Fast-check for TypeScript/JavaScript property-based testing
**Test Configuration:**
- Minimum 100 iterations per property test
- Each property test references its design document property
- Tag format: **Feature: erp-system-improvements, Property {number}: {property_text}**

**Example Property Test Structure:**
```typescript
describe('ERP System Improvements', () => {
  it('Property 1: Client Data Loading Reliability', () => {
    fc.assert(fc.property(
      fc.oneof(fc.constant('shipping'), fc.constant('banking')),
      fc.array(fc.record({ /* data structure */ })),
      (moduleType, mockData) => {
        // Test that data loading returns valid data or appropriate states
        // Feature: erp-system-improvements, Property 1: Client Data Loading Reliability
      }
    ), { numRuns: 100 })
  })
})
```

### Testing Priorities

**High Priority:**
- Data loading and error handling (Properties 1, 2)
- Form validation and persistence (Properties 3, 16)
- Operation management (Properties 4, 5, 6)

**Medium Priority:**
- UI component behavior (Properties 7, 13, 14)
- Calculation accuracy (Properties 8, 11)
- Search and filtering (Properties 12, 15)

**Lower Priority:**
- Logging and monitoring (Properties 17, 18)
- User experience enhancements (Property 19)

### Integration Testing

**API Integration:**
- Test all new API endpoints
- Verify error response handling
- Test data persistence and retrieval
- Validate request/response schemas

**Component Integration:**
- Test form submission workflows
- Verify data flow between components
- Test navigation and routing
- Validate state management

**End-to-End Scenarios:**
- Complete buyer type creation workflow
- Sample operation management lifecycle
- Manufacturing operation CRUD operations
- Material specification management flow
```

Now I'll use the prework tool to analyze the acceptance criteria before writing correctness properties:

<function_calls>
<invoke name="prework">
<parameter name="featureName">erp-system-improvements